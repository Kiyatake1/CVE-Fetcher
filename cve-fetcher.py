import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import requests
import pandas as pd
import time
import threading
import os
import openpyxl
import platform

# Variável para verificar se a análise está em andamento
analise_em_andamento = False

def buscar_informacoes_cve(cve_id):
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    response = requests.get(url)

    if response.status_code == 200:
        cve_info = response.json()
        return cve_info
    else:
        print(f"Erro ao buscar informações para CVE ID: {cve_id}")
        print("Código de status HTTP:", response.status_code)
        return None
    pass

def processar_cve_ids():
    global analise_em_andamento

    if analise_em_andamento:
        messagebox.showinfo("Aviso", "A análise já está em andamento.")
        return

    analise_em_andamento = True

    if platform.system() == "Linux":
        # Executar a análise automaticamente sem solicitar um arquivo de texto
        arquivo_cve_ids = "automatic_analysis.txt"
    else:
        # Solicitar ao usuário que selecione um arquivo de texto
        arquivo_cve_ids = filedialog.askopenfilename(title="Selecione um arquivo de CVE IDs", filetypes=[("Arquivos de Texto", "*.txt")])

    if arquivo_cve_ids:
        # Check if the script is running on Linux
        if platform.system() == "Linux":
            # Run debsecan and create the txt file with its output
            os.system("debsecan > vulnerabilities.txt")
            arquivo_cve_ids = "vulnerabilities.txt"
            
        # Nome do arquivo Excel
        nome_arquivo_excel = 'vulnerabilities.xlsx'
        
        # Crie uma thread para processar o arquivo
        def processar_thread():
            parar_processamento[0] = False
            botao_processar.config(state="disabled")
            botao_parar.config(state="active")
            if os.path.isfile(nome_arquivo_excel):
                os.remove(nome_arquivo_excel)  # Remove the existing file
            if not os.path.isfile(nome_arquivo_excel):
                df = pd.DataFrame(columns=["CVE ID", "Package", "Published Date", "Last Modified Date", "Description", "Version", "Vector String", "Attack Vector", "Attack Complexity", "Privileges Required", "User Interaction", "Scope", "Confidentiality Impact", "Integrity Impact", "Availability Impact", "Base Score", "Base Severity", "Exploitability Score", "Impact Score"])
                df.to_excel(nome_arquivo_excel, index=False, engine="openpyxl")
            else:
                df = pd.read_excel(nome_arquivo_excel, engine="openpyxl")

            with open(arquivo_cve_ids, "r", encoding="utf-8") as file:
                cve_ids = file.read().splitlines()

            if cve_ids:
                progresso_barra["maximum"] = len(cve_ids)
                progresso_barra["value"] = 0

            for cve_id_value in cve_ids:
                if parar_processamento[0]:
                    break

                cve_info = buscar_informacoes_cve(cve_id_value.split()[0])
                linkcve = f"https://nvd.nist.gov/vuln/detail/{cve_id_value.split()[0]}"
                package = cve_id_value.split()[1]
                if cve_info and "vulnerabilities" in cve_info:
                    vulnerabilities = cve_info["vulnerabilities"]
                    if vulnerabilities:
                        for vulnerability in vulnerabilities:
                            cve_data = vulnerability.get("cve", {})
                            published_date = cve_data.get("published", "ERROR")
                            last_modified_date = cve_data.get("lastModified", "ERROR")
                            description = cve_data.get("descriptions", [{}])[0].get("value", "ERROR")
                            # Remove quebras de linha e espaços extras da descrição
                            description = ' '.join(description.split())
                            metrics = cve_data.get("metrics", {})
                            cvss_metrics = metrics.get("cvssMetricV31", [{}])[0].get("cvssData", {})
                            version = cvss_metrics.get("version", "ERROR")
                            vector_string = cvss_metrics.get("vectorString", "ERROR")
                            attack_vector = cvss_metrics.get("attackVector", "ERROR")
                            attack_complexity = cvss_metrics.get("attackComplexity", "ERROR")
                            privileges_required = cvss_metrics.get("privilegesRequired", "ERROR")
                            user_interaction = cvss_metrics.get("userInteraction", "ERROR")
                            scope = cvss_metrics.get("scope", "ERROR")
                            confidentiality_impact = cvss_metrics.get("confidentialityImpact", "ERROR")
                            integrity_impact = cvss_metrics.get("integrityImpact", "ERROR")
                            availability_impact = cvss_metrics.get("availabilityImpact", "ERROR")
                            base_score = cvss_metrics.get("baseScore", "ERROR")
                            base_severity = cvss_metrics.get("baseSeverity", "ERROR")
                            exploitability_score = metrics.get("cvssMetricV31", [{}])[0].get("exploitabilityScore", "ERROR")
                            impact_score = metrics.get("cvssMetricV31", [{}])[0].get("impactScore", "ERROR")

                            row_to_append = {
                                "CVE ID": cve_data.get("id", ""),
                                "Package": cve_id_value.split()[1],
                                "Published Date": published_date,
                                "Last Modified Date": last_modified_date,
                                "Description": description,
                                "Version": version,
                                "Vector String": vector_string,
                                "Attack Vector": attack_vector,
                                "Attack Complexity": attack_complexity,
                                "Privileges Required": privileges_required,
                                "User Interaction": user_interaction,
                                "Scope": scope,
                                "Confidentiality Impact": confidentiality_impact,
                                "Integrity Impact": integrity_impact,
                                "Availability Impact": availability_impact,
                                "Base Score": base_score,
                                "Base Severity": base_severity,
                                "Exploitability Score": exploitability_score,
                                "Impact Score": impact_score,
                                "Link CVE": linkcve,
                            }
                            df = pd.concat([df, pd.DataFrame([row_to_append])])

                    else:
                        print(f"Nenhuma informação encontrada para CVE ID {cve_id_value.split()[0]}.")
                        # Adicione linhas com "ERROR" para indicar falta de informações
                        row_to_append = {
                            "CVE ID": cve_id_value.split()[0],
                            "Package": cve_id_value.split()[1],
                            "Published Date": "ERROR",
                            "Last Modified Date": "ERROR",
                            "Description": "ERROR",
                            "Version": "ERROR",
                            "Vector String": "ERROR",
                            "Attack Vector": "ERROR",
                            "Attack Complexity": "ERROR",
                            "Privileges Required": "ERROR",
                            "User Interaction": "ERROR",
                            "Scope": "ERROR",
                            "Confidentiality Impact": "ERROR",
                            "Integrity Impact": "ERROR",
                            "Availability Impact": "ERROR",
                            "Base Score": "ERROR",
                            "Base Severity": "ERROR",
                            "Exploitability Score": "ERROR",
                            "Impact Score": "ERROR",
                            "Link CVE": "ERROR",
                        }
                        df = pd.concat([df, pd.DataFrame([row_to_append])])

                progresso_barra["value"] += 1
                num_vulnerabilidades_label.config(text=f"{progresso_barra['value']}/{progresso_barra['maximum']}")
                processo_atual_label.config(text=f"Status: Requisitando {cve_id_value.split()[0]} ao NVD via API")
                time.sleep(6)

            if not parar_processamento[0]:
                if os.path.isfile(nome_arquivo_excel):
                     os.remove(nome_arquivo_excel)  # Remove o arquivo existente
                df.to_excel(nome_arquivo_excel, index=False, engine="openpyxl")
                print("Operação concluída. O arquivo Excel foi gerado.")
                messagebox.showinfo("Concluído", "Planilha Gerada com Sucesso!")
                processo_atual_label.config(text="Status: Aguardando novo arquivo .txt")
                progresso_barra["value"] = 0
                botao_processar.config(state="active")
                botao_parar.config(state="disabled")
            if parar_processamento[0]:
                if os.path.isfile(nome_arquivo_excel):
                    os.remove(nome_arquivo_excel)  # Remove o arquivo existente
                df.to_excel(nome_arquivo_excel, index=False, engine="openpyxl")
                print("Processamento interrompido pelo usuário.")
                messagebox.showinfo("Interrompido pelo Usuário", "Planilha Gerada com Sucesso!")
                processo_atual_label.config(text="Status: Aguardando novo arquivo .txt")
                progresso_barra["value"] = 0
                botao_processar.config(state="active")
                botao_parar.config(state="disabled")
                    
        # Inicie a thread
        thread = threading.Thread(target=processar_thread)
        thread.start()
    else:
        print("Nenhum arquivo de CVE IDs selecionado.")
    analise_em_andamento = False
    
def parar_processamento():
    global parar_processamento
    parar_processamento[0] = True
    botao_processar.config(state="active")
    botao_parar.config(state="disabled")
    processo_atual_label.config(text="Status: Aguardando novo arquivo .txt")
    progresso_barra["value"] = 0

# Crie uma janela Tkinter
janela = tk.Tk()
janela.title("CVE-Fetcher")

# Crie um botão para processar CVE IDs
botao_processar = tk.Button(janela, text="Processar CVE IDs", command=processar_cve_ids, state="active")

# Crie um botão para parar o processamento
botao_parar = tk.Button(janela, text="Parar Processamento", command=parar_processamento, state="disabled")

# Crie uma barra de progresso usando o widget Progressbar do ttk
style = ttk.Style()
style.configure("TProgressbar", thickness=30)
progresso_barra = ttk.Progressbar(janela, length=300, mode="determinate")

# Crie um campo de texto para exibir o número de vulnerabilidades processadas
num_vulnerabilidades_label = tk.Label(janela, text="0/0")

# Crie um campo de texto para exibir o processo atual
processo_atual_label = tk.Label(janela, text="Status: Aguardando novo arquivo .txt")

# Adicione os widgets à janela
botao_processar.pack()
botao_parar.pack()
progresso_barra.pack()
num_vulnerabilidades_label.pack()
processo_atual_label.pack()

# Variável global para controlar o processo de parar
parar_processamento = [False]

# Inicie a interface gráfica
janela.mainloop()

